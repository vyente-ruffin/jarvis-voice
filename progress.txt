# Progress Log

## Learnings
(Patterns discovered during previous implementation)

- Use `python3` not `python` on this system
- Use `pip3` not `pip` on this system
- Run mypy on specific files to avoid pre-existing type errors in voice_live.py/server.py
- Pre-existing test failures exist due to Azure SDK import issues (not related to memory modules)
- Use websocket.scope.get("query_string", b"") to get raw query string
- parse_qs returns lists, so access with [0] for single values
- Azure Voice Live SDK uses FunctionTool objects, not raw dicts - must convert MEMORY_TOOLS
- ToolChoiceLiteral.AUTO enables automatic tool selection
- Import Tool as base type for list annotation: `list[Tool]`
- RequestSession accepts `tools` and `tool_choice` parameters
- Azure Voice Live SDK function call flow:
  1. CONVERSATION_ITEM_CREATED with ItemType.FUNCTION_CALL gives name, call_id, item.id
  2. RESPONSE_FUNCTION_CALL_ARGUMENTS_DONE gives the arguments JSON string
  3. After processing, send FunctionCallOutputItem via conversation.item.create
  4. Call response.create() to trigger the AI to continue with the result
- Arguments come as a JSON string that needs json.loads()
- Memory functions need user_id injected since AI doesn't know it
- FunctionCallOutputItem requires call_id and output (JSON string)
- conversation.item.create needs previous_item_id to maintain order
- Static files are in src/static/ not just static/
- Script must be included before app.js so functions are available
- All 70 tests pass (5 skipped as expected)

---

## MCP Server Requirements
- Code/Library docs → Context7 MCP server ONLY
- Microsoft/Azure docs → Microsoft Learn MCP server ONLY
- Azure operations → Azure MCP server ONLY
- Playwright testing → Context7 for Playwright docs

---

## Completed Stories (New PRD.md)

### US-001: Extract user_id from WebSocket connection ✅
- Implemented user_id extraction from query params in server.py
- Added user_id parameter to VoiceLiveSession
- All server tests pass

### US-002: Add memory tools to VoiceLiveSession ✅
- Added FunctionTool/ToolChoiceLiteral imports
- Converted MEMORY_TOOLS to FunctionTool objects
- Updated instructions with memory capabilities
- RequestSession configured with tools and tool_choice=AUTO

### US-003: Handle function call events ✅
- Added CONVERSATION_ITEM_CREATED handler for FUNCTION_CALL type
- Added RESPONSE_FUNCTION_CALL_ARGUMENTS_DONE handler
- Implemented _execute_function_call method
- Sends FunctionCallOutputItem and calls response.create()

### US-004: Add memory status callback ✅
- Memory status forwarded to WebSocket client
- on_function_call callback implemented

### US-005: Frontend user_id generation ✅
- user-id.js copied to src/static/js/
- index.html includes user-id.js script
- app.js uses buildWebSocketUrl() with user_id
- User ID suffix displayed in UI

### US-006: Memory status indicator in UI ✅
- CSS styling for memory status states added
- Memory status messages handled in app.js

### US-007: Add environment variables ✅
- .env.example updated with MEMORY_API_URL, MEMORY_TIMEOUT_SECONDS, ENABLE_MEMORY
- README.md updated with memory environment variables

### US-008: Copy memory tests ✅
- test_memory_client.py copied
- test_tool_handler.py copied
- test_memory_integration.py copied (renamed from test_integration.py)
- All 70 tests pass (5 skipped as expected)

---

### US-009: Playwright E2E test - Connect with user_id ✅
- Added pytest-playwright to requirements.txt
- Created tests/test_e2e.py with TestWebSocketConnection class
- Tests verify:
  - WebSocket connection includes user_id query param
  - user_id persisted in localStorage
  - user_id preserved on page refresh
  - user_id suffix displayed in UI
- All 4 tests pass

---

## Iteration 10 - US-009
- Implemented Playwright E2E tests for WebSocket connection with user_id
- Files changed:
  - requirements.txt (added pytest-playwright)
  - tests/test_e2e.py (created with 4 tests)
- Learnings for future iterations:
  - Server must be running for E2E tests
  - Use page.on("websocket", handler) to capture WebSocket connections
  - Use page.evaluate() to access localStorage
  - Use page.reload() for refresh tests
---

### US-010: Playwright E2E test - Mute/unmute functionality ✅
- Implemented 3 Playwright E2E tests in TestMuteUnmute class
- Files changed:
  - tests/test_e2e.py (added TestMuteUnmute class)
  - PRD.md (marked acceptance criteria complete)
- Learnings for future iterations:
  - Use re.compile(r'\bmuted\b') for class matching to avoid partial matches
  - Mute button uses class toggle, not attribute
  - User status element shows "Muted" text and has "muted" class when muted

---

## Iteration 11 - US-010
- Implemented Playwright E2E tests for mute/unmute functionality
- Files changed:
  - tests/test_e2e.py (added 3 tests in TestMuteUnmute class)
- Learnings for future iterations:
  - Server was already running on port 8000 from previous iteration
  - All 8 E2E tests pass

---

### US-011: Playwright E2E test - Reconnection ✅
- Implemented 3 Playwright E2E tests in TestReconnection class
- Files changed:
  - tests/test_e2e.py (added TestReconnection class)
  - PRD.md (marked acceptance criteria complete)
- Learnings for future iterations:
  - Use page.evaluate("ws.close()") to trigger WebSocket disconnect from client
  - Reconnect timeout is 2 seconds (wait 3s+ in tests for buffer)
  - WebSocket events captured via page.on("websocket", handler)
  - Capture URLs in list for comparing across reconnects

---

## Iteration 12 - US-011
- Implemented Playwright E2E tests for WebSocket reconnection behavior
- Tests verify:
  - Status shows "Offline" on disconnect
  - Auto-reconnect after 2 seconds
  - Reconnection uses same user_id from localStorage
- All 11 E2E tests pass

---

### US-012: Playwright E2E test - Error handling ✅
- Implemented 3 Playwright E2E tests in TestErrorHandling class
- Files changed:
  - tests/test_e2e.py (added TestErrorHandling class)
  - PRD.md (marked acceptance criteria complete)
- Learnings for future iterations:
  - Use page.on("console", handler) to capture console.error logs
  - Use page.evaluate() to inject MessageEvent for simulating server messages
  - App has try-catch in handleMessage for JSON parse errors
  - Test graceful degradation by checking app still functions after errors

---

## Iteration 13 - US-012
- Implemented Playwright E2E tests for error handling
- Tests verify:
  - Server error messages are logged to console and don't crash app
  - Invalid JSON messages are handled gracefully
  - App recovers after multiple consecutive errors
- All 14 E2E tests pass

---

## Next: US-013 - Dockerfile for production

Ralph will start from here.

---

### US-013: Dockerfile for production ✅
- Created multi-stage Dockerfile with Python 3.11 slim base
- Builder stage: installs gcc and creates venv
- Production stage: copies venv, app code, creates non-root user
- Added HEALTHCHECK instruction for container health monitoring
- Files changed:
  - Dockerfile (updated with multi-stage build)
- Learnings for future iterations:
  - Multi-stage builds reduce final image size by excluding build tools
  - Use HEALTHCHECK for container orchestration (Azure Container Apps)
  - Non-root user improves container security
  - Virtual environment in /opt/venv keeps dependencies isolated

---

## Iteration 14 - US-014: Azure Container Apps deployment ✅
- Updated infra/main.bicep with:
  - Latest API versions (2025-01-01 for Container Apps, 2025-04-01 for ACR)
  - Memory environment variables (MEMORY_API_URL, MEMORY_TIMEOUT_SECONDS, ENABLE_MEMORY)
  - Correct env var names (AZURE_VOICE_LIVE_* to match server.py)
  - Liveness and readiness probes for /health endpoint
  - System-assigned managed identity for ACR pull (more secure than admin credentials)
  - AcrPull role assignment for the Container App identity
- Deployed to Azure:
  - ACR: jarvisacrafttmtxdb5reg.azurecr.io
  - Container App URL: https://jarvis-api.lemonbay-c4ff031f.eastus2.azurecontainerapps.io
  - /health endpoint returns 200 ✓
  - WebSocket /ws/voice works ✓
- Files changed:
  - infra/main.bicep (updated with managed identity)
  - PRD.md (marked acceptance criteria complete)
- Learnings for future iterations:
  - Use managed identity for ACR pull instead of admin credentials (more reliable)
  - Admin credentials can cause ImagePullBackOff issues
  - Use `az acr build` to build images directly in Azure if local push fails
  - Role assignment propagation takes a few seconds
  - curl cannot test WebSocket endpoints - use Python websockets library
  - Container Apps logs via `az containerapp logs show --type console`

---

## Iteration 15 - US-015: Application Insights monitoring ✅
- Added Application Insights resource to infra/main.bicep:
  - Workspace-based Application Insights linked to Log Analytics
  - APPLICATIONINSIGHTS_CONNECTION_STRING env var configured
- Added OpenTelemetry instrumentation:
  - azure-monitor-opentelemetry==1.6.0
  - opentelemetry-instrumentation-fastapi==0.47b0
- Added custom telemetry in tool_handler.py:
  - Memory operation spans with latency tracking
  - Attributes: operation, user_id, latency_ms, success, result_count
- Deployed to Azure:
  - Application Insights: jarvis-appi-afttmtxdb5reg
  - Telemetry flowing (logs show "Items accepted")
- Files changed:
  - infra/main.bicep (added Application Insights resource)
  - requirements.txt (added OpenTelemetry dependencies)
  - src/server.py (added OpenTelemetry initialization)
  - src/tool_handler.py (added memory operation telemetry)
  - PRD.md (marked acceptance criteria complete)
- Learnings for future iterations:
  - Use workspace-based Application Insights (newer pattern)
  - azure-monitor-opentelemetry auto-instruments FastAPI
  - Custom spans for specific operations with tracer.start_as_current_span()
  - Telemetry data appears in Application Insights after a few minutes delay

---

## Iteration 16 - US-016: End-to-end production test (Partial)
- Ran Playwright E2E tests against production URL
- All 14 tests passed in 24.15s
- Production URL: https://jarvis-api.lemonbay-c4ff031f.eastus2.azurecontainerapps.io
- Files changed:
  - PRD.md (marked E2E tests criterion complete)
- Remaining acceptance criteria require MANUAL voice testing:
  - Memory stored successfully (logs show add_memory)
  - Memory recalled successfully (logs show search_memory)
  - UI status indicators work in production
  - Latency <500ms in Application Insights
- Learnings for future iterations:
  - Resource group is rg-youni-dev (not rg-jarvis-voice-eastus2-001)
  - Use `az monitor app-insights query` to query Application Insights
  - Telemetry may take time to propagate after deployment

---

## Next: Manual testing required for US-016

The remaining US-016 criteria require human voice interaction:
1. Open https://jarvis-api.lemonbay-c4ff031f.eastus2.azurecontainerapps.io
2. Say "My name is [your name]"
3. Verify UI shows "Storing memory..."
4. Check Application Insights for add_memory event
5. Refresh browser
6. Say "What's my name?"
7. Verify JARVIS responds correctly

---
