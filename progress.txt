# Progress Log

## Learnings
(Patterns discovered during previous implementation)

- Use `python3` not `python` on this system
- Use `pip3` not `pip` on this system
- Run mypy on specific files to avoid pre-existing type errors in voice_live.py/server.py
- Pre-existing test failures exist due to Azure SDK import issues (not related to memory modules)
- Use websocket.scope.get("query_string", b"") to get raw query string
- parse_qs returns lists, so access with [0] for single values
- Azure Voice Live SDK uses FunctionTool objects, not raw dicts - must convert MEMORY_TOOLS
- ToolChoiceLiteral.AUTO enables automatic tool selection
- Import Tool as base type for list annotation: `list[Tool]`
- RequestSession accepts `tools` and `tool_choice` parameters
- Azure Voice Live SDK function call flow:
  1. CONVERSATION_ITEM_CREATED with ItemType.FUNCTION_CALL gives name, call_id, item.id
  2. RESPONSE_FUNCTION_CALL_ARGUMENTS_DONE gives the arguments JSON string
  3. After processing, send FunctionCallOutputItem via conversation.item.create
  4. Call response.create() to trigger the AI to continue with the result
- Arguments come as a JSON string that needs json.loads()
- Memory functions need user_id injected since AI doesn't know it
- FunctionCallOutputItem requires call_id and output (JSON string)
- conversation.item.create needs previous_item_id to maintain order
- Static files are in src/static/ not just static/
- Script must be included before app.js so functions are available
- All 70 tests pass (5 skipped as expected)

---

## MCP Server Requirements
- Code/Library docs → Context7 MCP server ONLY
- Microsoft/Azure docs → Microsoft Learn MCP server ONLY
- Azure operations → Azure MCP server ONLY
- Playwright testing → Context7 for Playwright docs

---

## Completed Stories (New PRD.md)

### US-001: Extract user_id from WebSocket connection ✅
- Implemented user_id extraction from query params in server.py
- Added user_id parameter to VoiceLiveSession
- All server tests pass

### US-002: Add memory tools to VoiceLiveSession ✅
- Added FunctionTool/ToolChoiceLiteral imports
- Converted MEMORY_TOOLS to FunctionTool objects
- Updated instructions with memory capabilities
- RequestSession configured with tools and tool_choice=AUTO

### US-003: Handle function call events ✅
- Added CONVERSATION_ITEM_CREATED handler for FUNCTION_CALL type
- Added RESPONSE_FUNCTION_CALL_ARGUMENTS_DONE handler
- Implemented _execute_function_call method
- Sends FunctionCallOutputItem and calls response.create()

### US-004: Add memory status callback ✅
- Memory status forwarded to WebSocket client
- on_function_call callback implemented

### US-005: Frontend user_id generation ✅
- user-id.js copied to src/static/js/
- index.html includes user-id.js script
- app.js uses buildWebSocketUrl() with user_id
- User ID suffix displayed in UI

### US-006: Memory status indicator in UI ✅
- CSS styling for memory status states added
- Memory status messages handled in app.js

### US-007: Add environment variables ✅
- .env.example updated with MEMORY_API_URL, MEMORY_TIMEOUT_SECONDS, ENABLE_MEMORY
- README.md updated with memory environment variables

### US-008: Copy memory tests ✅
- test_memory_client.py copied
- test_tool_handler.py copied
- test_memory_integration.py copied (renamed from test_integration.py)
- All 70 tests pass (5 skipped as expected)

---

### US-009: Playwright E2E test - Connect with user_id ✅
- Added pytest-playwright to requirements.txt
- Created tests/test_e2e.py with TestWebSocketConnection class
- Tests verify:
  - WebSocket connection includes user_id query param
  - user_id persisted in localStorage
  - user_id preserved on page refresh
  - user_id suffix displayed in UI
- All 4 tests pass

---

## Iteration 10 - US-009
- Implemented Playwright E2E tests for WebSocket connection with user_id
- Files changed:
  - requirements.txt (added pytest-playwright)
  - tests/test_e2e.py (created with 4 tests)
- Learnings for future iterations:
  - Server must be running for E2E tests
  - Use page.on("websocket", handler) to capture WebSocket connections
  - Use page.evaluate() to access localStorage
  - Use page.reload() for refresh tests
---

### US-010: Playwright E2E test - Mute/unmute functionality ✅
- Implemented 3 Playwright E2E tests in TestMuteUnmute class
- Files changed:
  - tests/test_e2e.py (added TestMuteUnmute class)
  - PRD.md (marked acceptance criteria complete)
- Learnings for future iterations:
  - Use re.compile(r'\bmuted\b') for class matching to avoid partial matches
  - Mute button uses class toggle, not attribute
  - User status element shows "Muted" text and has "muted" class when muted

---

## Iteration 11 - US-010
- Implemented Playwright E2E tests for mute/unmute functionality
- Files changed:
  - tests/test_e2e.py (added 3 tests in TestMuteUnmute class)
- Learnings for future iterations:
  - Server was already running on port 8000 from previous iteration
  - All 8 E2E tests pass

---

### US-011: Playwright E2E test - Reconnection ✅
- Implemented 3 Playwright E2E tests in TestReconnection class
- Files changed:
  - tests/test_e2e.py (added TestReconnection class)
  - PRD.md (marked acceptance criteria complete)
- Learnings for future iterations:
  - Use page.evaluate("ws.close()") to trigger WebSocket disconnect from client
  - Reconnect timeout is 2 seconds (wait 3s+ in tests for buffer)
  - WebSocket events captured via page.on("websocket", handler)
  - Capture URLs in list for comparing across reconnects

---

## Iteration 12 - US-011
- Implemented Playwright E2E tests for WebSocket reconnection behavior
- Tests verify:
  - Status shows "Offline" on disconnect
  - Auto-reconnect after 2 seconds
  - Reconnection uses same user_id from localStorage
- All 11 E2E tests pass

---

### US-012: Playwright E2E test - Error handling ✅
- Implemented 3 Playwright E2E tests in TestErrorHandling class
- Files changed:
  - tests/test_e2e.py (added TestErrorHandling class)
  - PRD.md (marked acceptance criteria complete)
- Learnings for future iterations:
  - Use page.on("console", handler) to capture console.error logs
  - Use page.evaluate() to inject MessageEvent for simulating server messages
  - App has try-catch in handleMessage for JSON parse errors
  - Test graceful degradation by checking app still functions after errors

---

## Iteration 13 - US-012
- Implemented Playwright E2E tests for error handling
- Tests verify:
  - Server error messages are logged to console and don't crash app
  - Invalid JSON messages are handled gracefully
  - App recovers after multiple consecutive errors
- All 14 E2E tests pass

---

## Next: US-013 - Dockerfile for production

Ralph will start from here.

---

### US-013: Dockerfile for production ✅
- Created multi-stage Dockerfile with Python 3.11 slim base
- Builder stage: installs gcc and creates venv
- Production stage: copies venv, app code, creates non-root user
- Added HEALTHCHECK instruction for container health monitoring
- Files changed:
  - Dockerfile (updated with multi-stage build)
- Learnings for future iterations:
  - Multi-stage builds reduce final image size by excluding build tools
  - Use HEALTHCHECK for container orchestration (Azure Container Apps)
  - Non-root user improves container security
  - Virtual environment in /opt/venv keeps dependencies isolated

---
